// Generated by prisma-flare - DO NOT EDIT
// FlareClient wrapper for the new prisma-client provider
// This file is TypeScript and will be compiled with your code

import { PrismaClient, Prisma } from './client.js';
import { createFlareClient, FlareBuilder as FlareBuilderImpl } from 'prisma-flare';
import type { FlareClientOptions, PaginatedResult } from 'prisma-flare';

// ============================================================================
// Type Helpers - Using YOUR Prisma client types
// ============================================================================

/**
 * Extract model names from PrismaClient (lowercase delegate names only).
 */
type RawPrismaClientKeys = Exclude<
  Extract<keyof PrismaClient, string>,
  | '$connect'
  | '$disconnect'
  | '$on'
  | '$transaction'
  | '$use'
  | '$extends'
  | '$executeRaw'
  | '$executeRawUnsafe'
  | '$queryRaw'
  | '$queryRawUnsafe'
>;

export type ModelName = RawPrismaClientKeys;
export type ModelDelegate<T extends ModelName> = Uncapitalize<T> extends keyof PrismaClient
  ? PrismaClient[Uncapitalize<T>]
  : never;
export type RecordType<T extends ModelName> = NonNullable<Awaited<ReturnType<ModelDelegate<T>['findFirst']>>>;

/** Get Prisma args type for a model operation */
type PrismaArgs<T extends ModelName, A extends keyof ModelDelegate<T>> =
  ModelDelegate<T>[A] extends (args: infer Args) => any ? Args :
  ModelDelegate<T>[A] extends (args?: infer Args) => any ? Args : never;

/** FindMany args type */
type FindManyArgs<T extends ModelName> = NonNullable<PrismaArgs<T, 'findMany'>>;

/** Where input type (for findMany, etc.) */
type WhereInput<T extends ModelName> = FindManyArgs<T> extends { where?: infer W } ? W : never;

/** OrderBy input type */
type OrderByInput<T extends ModelName> = FindManyArgs<T> extends { orderBy?: infer O } ? O : never;

/** Select input type */
type SelectInput<T extends ModelName> = FindManyArgs<T> extends { select?: infer S } ? S : never;

/** Include input type */
type IncludeInput<T extends ModelName> = FindManyArgs<T> extends { include?: infer I } ? I : never;

/** Distinct input type */
type DistinctInput<T extends ModelName> = FindManyArgs<T> extends { distinct?: infer D } ? D : never;

/** Create data type */
type CreateData<T extends ModelName> = NonNullable<PrismaArgs<T, 'create'>> extends { data: infer D } ? D : never;

/** CreateMany data type */
type CreateManyData<T extends ModelName> = 'createMany' extends keyof ModelDelegate<T>
  ? NonNullable<PrismaArgs<T, 'createMany'>> extends { data: infer D } ? D : never
  : never;

/** Update data type */
type UpdateData<T extends ModelName> = NonNullable<PrismaArgs<T, 'update'>> extends { data: infer D } ? D : never;

/** Helper to make where clause optional */
type OptionalWhere<T> = T extends { where: any } ? Omit<T, 'where'> & { where?: T['where'] } : T;

/** Upsert args type (with optional where, includes compound unique constraints) */
type UpsertArgs<T extends ModelName> = OptionalWhere<NonNullable<PrismaArgs<T, 'upsert'>>>;

/** Delete args type (with optional where, includes compound unique constraints) */
type DeleteArgs<T extends ModelName> = OptionalWhere<NonNullable<PrismaArgs<T, 'delete'>>>;

/** DeleteMany args type */
type DeleteManyArgs<T extends ModelName> = NonNullable<PrismaArgs<T, 'deleteMany'>>;

/** GroupBy args type */
type GroupByArgs<T extends ModelName> = NonNullable<PrismaArgs<T, 'groupBy'>>;

/** GroupBy input type */
type GroupByInput<T extends ModelName> = GroupByArgs<T> extends { by: infer B } ? B : never;

/** Having input type */
type HavingInput<T extends ModelName> = GroupByArgs<T> extends { having?: infer H } ? H : never;

/** Aggregate args type */
type AggregateArgs<T extends ModelName> = NonNullable<PrismaArgs<T, 'aggregate'>>;

type SumFields<T extends ModelName> = AggregateArgs<T> extends { _sum?: infer S } ? keyof S : string;
type AvgFields<T extends ModelName> = AggregateArgs<T> extends { _avg?: infer A } ? keyof A : string;
type MinFields<T extends ModelName> = AggregateArgs<T> extends { _min?: infer M } ? keyof M : string;
type MaxFields<T extends ModelName> = AggregateArgs<T> extends { _max?: infer M } ? keyof M : string;

type IncludeMap<T extends ModelName> = NonNullable<IncludeInput<T>>;
type IncludeKey<T extends ModelName> = keyof IncludeMap<T> & string;

// ============================================================================
// FlareBuilder - Type definition using YOUR Prisma types
// ============================================================================

/**
 * FlareBuilder provides a fluent query builder API with full type safety.
 */
export interface IFlareBuilder<
  T extends ModelName,
  Args extends Record<string, any> = Record<string, never>
> {
  // Query Building Methods - Where conditions
  where(condition: WhereInput<T>): IFlareBuilder<T, Args & { where: WhereInput<T> }>;
  andWhere(condition: WhereInput<T>): IFlareBuilder<T, Args & { where: WhereInput<T> }>;
  orWhere(condition: WhereInput<T>): IFlareBuilder<T, Args & { where: WhereInput<T> }>;
  whereGroup(callback: (builder: IFlareBuilder<T, Record<string, never>>) => IFlareBuilder<T, any>, mode?: 'AND' | 'OR'): IFlareBuilder<T, Args & { where: WhereInput<T> }>;
  orWhereGroup(callback: (builder: IFlareBuilder<T, Record<string, never>>) => IFlareBuilder<T, any>): IFlareBuilder<T, Args & { where: WhereInput<T> }>;
  withId(id: number | string): IFlareBuilder<T, Args & { where: { id: number | string } }>;

  // Query Building Methods - Ordering and Limiting
  order(orderBy: OrderByInput<T>): IFlareBuilder<T, Args & { orderBy: OrderByInput<T> }>;
  first(key?: keyof RecordType<T> | string): IFlareBuilder<T, Args & { orderBy: any; take: number }>;
  last(key?: keyof RecordType<T> | string): IFlareBuilder<T, Args & { orderBy: any; take: number }>;
  limit(count: number): IFlareBuilder<T, Args & { take: number }>;
  skip(count: number): IFlareBuilder<T, Args & { skip: number }>;
  take(count: number): IFlareBuilder<T, Args & { take: number }>;
  offset(count: number): IFlareBuilder<T, Args & { skip: number }>;
  cursor(cursor: Record<string, any>): IFlareBuilder<T, Args>;
  distinct(fields: DistinctInput<T>): IFlareBuilder<T, Args & { distinct: DistinctInput<T> }>;

  // Query Building Methods - Selection
  select<S extends SelectInput<T>>(fields: S): IFlareBuilder<T, Args & { select: S }>;
  include<K extends IncludeKey<T>>(relation: K, callback?: (builder: any) => any): IFlareBuilder<T, Args & { include: Record<K, true> }>;

  // Read Operations
  findMany(): Promise<RecordType<T>[]>;
  findFirst(): Promise<RecordType<T> | null>;
  findFirstOrThrow(): Promise<RecordType<T>>;
  findUnique(): Promise<RecordType<T> | null>;
  findUniqueOrThrow(): Promise<RecordType<T>>;
  all(): Promise<RecordType<T>[]>;
  get(): Promise<RecordType<T>[]>;
  pluck<K extends keyof RecordType<T>>(field: K): Promise<Array<RecordType<T>[K]>>;
  only<K extends keyof RecordType<T>>(field: K): Promise<RecordType<T>[K] | null>;

  // Write Operations
  create(data: CreateData<T>): Promise<RecordType<T>>;
  createMany(data: CreateManyData<T>): Promise<{ count: number }>;
  update(data: UpdateData<T>): Promise<RecordType<T>>;
  updateMany(data: UpdateData<T>): Promise<{ count: number }>;
  upsert(args?: UpsertArgs<T>): Promise<RecordType<T>>;
  delete(args?: DeleteArgs<T>): Promise<RecordType<T>>;
  deleteMany(args?: DeleteManyArgs<T>): Promise<{ count: number }>;

  // Aggregations
  count(): Promise<number>;
  sum<F extends SumFields<T>>(field: F): Promise<number | null>;
  avg<F extends AvgFields<T>>(field: F): Promise<number | null>;
  min<F extends MinFields<T>>(field: F): Promise<any>;
  max<F extends MaxFields<T>>(field: F): Promise<any>;
  aggregate(args: { _sum?: Partial<Record<SumFields<T>, true>>; _avg?: Partial<Record<AvgFields<T>, true>>; _min?: Partial<Record<MinFields<T>, true>>; _max?: Partial<Record<MaxFields<T>, true>>; _count?: boolean | Partial<Record<string, true>> }): Promise<any>;
  groupBy<B extends GroupByInput<T>>(by: B): IFlareBuilder<T, Args & { by: B }>;
  having(condition: HavingInput<T>): IFlareBuilder<T, Args & { having: HavingInput<T> }>;

  // Pagination
  paginate(page?: number, perPage?: number): Promise<PaginatedResult<RecordType<T>>>;

  // Existence Check
  exists(existenceKey?: string): Promise<boolean>;

  // Utilities
  when(condition: boolean | (() => boolean), callback: (qb: IFlareBuilder<T, Args>) => void): IFlareBuilder<T, Args>;
  chunk(size: number, callback: (results: RecordType<T>[]) => Promise<void> | void): Promise<void>;
  clone(): IFlareBuilder<T, Args>;
  getQuery(): Record<string, any>;
  toQuery(): Args;
}

// Export the FlareBuilder implementation with our interface type
export const FlareBuilder = FlareBuilderImpl as unknown as {
  new <T extends ModelName>(model: ModelDelegate<T>): IFlareBuilder<T>;
};

// Type alias for external use
export type FlareBuilder<
  T extends ModelName,
  Args extends Record<string, any> = Record<string, never>
> = IFlareBuilder<T, Args>;

// ============================================================================
// FlareClient - Properly typed for your Prisma schema
// ============================================================================

const _FlareClient = createFlareClient(PrismaClient, Prisma);

/**
 * FlareClient interface with proper typing for your Prisma schema.
 */
export interface IFlareClient extends PrismaClient {
  from<M extends ModelName>(modelName: M): IFlareBuilder<M>;
  transaction<R>(
    fn: (tx: IFlareClient) => Promise<R>,
    options?: { maxWait?: number; timeout?: number; isolationLevel?: any }
  ): Promise<R>;
}

// Export the FlareClient implementation with our interface type
export const FlareClient = _FlareClient as unknown as {
  new (options?: FlareClientOptions): IFlareClient;
};

// Type alias for external use
export type FlareClient = IFlareClient;

// Re-export Prisma types for convenience
export { PrismaClient, Prisma };
