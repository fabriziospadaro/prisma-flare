# How It Works

prisma-flare provides full type safety by generating type definitions that reference your specific Prisma client.

## Type Generation

### Default `@prisma/client`

When using the default Prisma client location, prisma-flare uses its bundled type definitions that work with `@prisma/client`.

### Custom Output with `prisma-client-js`

When you use a custom output path (e.g., `output = "./generated/client"`), prisma-flare generates a `.prisma-flare` module in `node_modules` that:

1. Imports `PrismaClient` and `Prisma` from your custom path
2. Re-exports `FlareBuilder` and `FlareClient` with types bound to YOUR Prisma client
3. Provides complete type inference for all query methods

```
node_modules/
└── .prisma-flare/
    ├── index.js      # Runtime code importing your Prisma client
    ├── index.d.ts    # Type definitions with your model types
    └── package.json
```

Your model classes import from `.prisma-flare` to get proper types:

```typescript
// prisma/models/User.ts (auto-generated)
import { FlareBuilder } from '.prisma-flare';

export default class User extends FlareBuilder<'user'> {
  // Full type safety for User model
}
```

### Custom Output with `prisma-client` (New Provider)

The new `prisma-client` provider generates TypeScript files directly. prisma-flare handles this by:

1. Generating `flare.ts` alongside your Prisma client with full type definitions
2. Also generating `.prisma-flare` module for model class imports
3. Using `.ts` imports since the Prisma client is TypeScript

```
prisma/generated/client/
├── client.ts         # Prisma-generated client
├── flare.ts          # prisma-flare generated types & client
└── ...
```

## The `DB` Class

The `DB` class is generated in `prisma-flare/generated` and provides static getters for each model:

```typescript
import { DB } from 'prisma-flare/generated';

// DB.users returns a new User() instance (FlareBuilder)
// DB.posts returns a new Post() instance (FlareBuilder)
// DB.instance returns the raw FlareClient
```

This is generated by `npx prisma-flare generate` based on your schema.

## Hook System Architecture

### Prisma ≤6: Legacy Middleware

Uses the `$use()` middleware API:

```typescript
prisma.$use(async (params, next) => {
  // beforeCreate, beforeUpdate, etc.
  const result = await next(params);
  // afterCreate, afterUpdate, etc.
  return result;
});
```

### Prisma 7+: Client Extensions

Uses the new extensions API:

```typescript
prisma.$extends({
  query: {
    $allModels: {
      async create({ args, query }) {
        // beforeCreate
        const result = await query(args);
        // afterCreate
        return result;
      }
    }
  }
});
```

prisma-flare automatically detects your Prisma version and uses the appropriate API.

## FlareBuilder Internals

The `FlareBuilder` class is a thin wrapper that:

1. Accumulates query options via chainable methods
2. Passes the final query to Prisma's delegate methods
3. Adds convenience methods (`pluck`, `only`, `paginate`, etc.)

```typescript
class FlareBuilder<T extends ModelName> {
  private query: QueryOptions = {};

  where(condition) {
    this.query.where = mergeWhere(this.query.where, condition);
    return this;
  }

  async findMany() {
    return this.model.findMany(this.query);
  }
}
```

### Performance

FlareBuilder adds virtually zero overhead:
- Object instantiation: ~0.001ms
- Method chaining: ~0.001ms per method
- Model registry lookup: ~0.001ms

Total overhead: **0.1-0.4%** per query (~0.001ms).
