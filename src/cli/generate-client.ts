import * as fs from 'fs';
import * as path from 'path';
import { findProjectRoot, loadConfig } from './config';
import { getPrismaClientPath, hasCustomPrismaOutput, getPrismaProvider } from './schema-parser';

/**
 * Generates complete type definitions for custom Prisma output paths.
 * This includes a fully typed FlareBuilder that uses the local Prisma namespace.
 */
function generateCustomOutputTypes(resolvedImport: string): string {
  return `// Generated by prisma-flare - DO NOT EDIT
// Complete type definitions for custom Prisma client output path

import { PrismaClient as BasePrismaClient, Prisma as BasePrisma } from '${resolvedImport}';
import type { FlareClientOptions, PaginatedResult } from 'prisma-flare';

// Re-export PrismaClient and Prisma from the configured path
export { BasePrismaClient as PrismaClient, BasePrisma as Prisma };

// ============================================================================
// Type Helpers - Using YOUR Prisma client types
// ============================================================================

/**
 * Extract model names from PrismaClient
 */
type RawPrismaClientKeys = Exclude<
  Extract<keyof BasePrismaClient, string>,
  | '$connect'
  | '$disconnect'
  | '$on'
  | '$transaction'
  | '$use'
  | '$extends'
  | '$executeRaw'
  | '$executeRawUnsafe'
  | '$queryRaw'
  | '$queryRawUnsafe'
>;

/** Model names from your Prisma schema */
export type ModelName = RawPrismaClientKeys;

/** Get the delegate type for a model */
export type ModelDelegate<T extends ModelName> = Uncapitalize<T> extends keyof BasePrismaClient
  ? BasePrismaClient[Uncapitalize<T>]
  : never;

/** Get the record type for a model */
export type RecordType<T extends ModelName> = NonNullable<Awaited<ReturnType<ModelDelegate<T>['findFirst']>>>;

/** Get Prisma args type for a model operation */
type PrismaArgs<T extends ModelName, A extends keyof ModelDelegate<T>> =
  ModelDelegate<T>[A] extends (args: infer Args) => any ? Args :
  ModelDelegate<T>[A] extends (args?: infer Args) => any ? Args : never;

/** FindMany args type */
type FindManyArgs<T extends ModelName> = NonNullable<PrismaArgs<T, 'findMany'>>;

/** Where input type */
type WhereInput<T extends ModelName> = FindManyArgs<T> extends { where?: infer W } ? W : never;

/** OrderBy input type */
type OrderByInput<T extends ModelName> = FindManyArgs<T> extends { orderBy?: infer O } ? O : never;

/** Select input type */
type SelectInput<T extends ModelName> = FindManyArgs<T> extends { select?: infer S } ? S : never;

/** Include input type */
type IncludeInput<T extends ModelName> = FindManyArgs<T> extends { include?: infer I } ? I : never;

/** Distinct input type */
type DistinctInput<T extends ModelName> = FindManyArgs<T> extends { distinct?: infer D } ? D : never;

/** Create data type */
type CreateData<T extends ModelName> = NonNullable<PrismaArgs<T, 'create'>> extends { data: infer D } ? D : never;

/** CreateMany data type */
type CreateManyData<T extends ModelName> = 'createMany' extends keyof ModelDelegate<T>
  ? NonNullable<PrismaArgs<T, 'createMany'>> extends { data: infer D } ? D : never
  : never;

/** Update data type */
type UpdateData<T extends ModelName> = NonNullable<PrismaArgs<T, 'update'>> extends { data: infer D } ? D : never;

/** GroupBy args type */
type GroupByArgs<T extends ModelName> = NonNullable<PrismaArgs<T, 'groupBy'>>;

/** GroupBy input type */
type GroupByInput<T extends ModelName> = GroupByArgs<T> extends { by: infer B } ? B : never;

/** Having input type */
type HavingInput<T extends ModelName> = GroupByArgs<T> extends { having?: infer H } ? H : never;

/** Aggregate args type */
type AggregateArgs<T extends ModelName> = NonNullable<PrismaArgs<T, 'aggregate'>>;

type SumFields<T extends ModelName> = AggregateArgs<T> extends { _sum?: infer S } ? keyof S : string;
type AvgFields<T extends ModelName> = AggregateArgs<T> extends { _avg?: infer A } ? keyof A : string;
type MinFields<T extends ModelName> = AggregateArgs<T> extends { _min?: infer M } ? keyof M : string;
type MaxFields<T extends ModelName> = AggregateArgs<T> extends { _max?: infer M } ? keyof M : string;

type IncludeMap<T extends ModelName> = NonNullable<IncludeInput<T>>;
type IncludeKey<T extends ModelName> = keyof IncludeMap<T> & string;

// ============================================================================
// FlareBuilder - Complete type definition using YOUR Prisma types
// ============================================================================

/**
 * FlareBuilder provides a fluent query builder API with full type safety.
 * This version uses your project's Prisma types for complete autocomplete support.
 */
export declare class FlareBuilder<
  T extends ModelName,
  Args extends Record<string, any> = Record<string, never>
> {
  constructor(model: ModelDelegate<T>);

  // Query Building Methods - Where conditions
  where(condition: WhereInput<T>): FlareBuilder<T, Args & { where: WhereInput<T> }>;
  andWhere(condition: WhereInput<T>): FlareBuilder<T, Args & { where: WhereInput<T> }>;
  orWhere(condition: WhereInput<T>): FlareBuilder<T, Args & { where: WhereInput<T> }>;
  whereGroup(callback: (builder: FlareBuilder<T, Record<string, never>>) => FlareBuilder<T, any>, mode?: 'AND' | 'OR'): FlareBuilder<T, Args & { where: WhereInput<T> }>;
  orWhereGroup(callback: (builder: FlareBuilder<T, Record<string, never>>) => FlareBuilder<T, any>): FlareBuilder<T, Args & { where: WhereInput<T> }>;
  withId(id: number | string): FlareBuilder<T, Args & { where: { id: number | string } }>;

  // Query Building Methods - Ordering and Limiting
  order(orderBy: OrderByInput<T>): FlareBuilder<T, Args & { orderBy: OrderByInput<T> }>;
  first(key?: keyof RecordType<T> | string): FlareBuilder<T, Args & { orderBy: any; take: number }>;
  last(key?: keyof RecordType<T> | string): FlareBuilder<T, Args & { orderBy: any; take: number }>;
  limit(count: number): FlareBuilder<T, Args & { take: number }>;
  skip(count: number): FlareBuilder<T, Args & { skip: number }>;
  take(count: number): FlareBuilder<T, Args & { take: number }>;
  offset(count: number): FlareBuilder<T, Args & { skip: number }>;
  cursor(cursor: Record<string, any>): FlareBuilder<T, Args>;
  distinct(fields: DistinctInput<T>): FlareBuilder<T, Args & { distinct: DistinctInput<T> }>;

  // Query Building Methods - Selection
  select<S extends SelectInput<T>>(fields: S): FlareBuilder<T, Args & { select: S }>;
  include<K extends IncludeKey<T>>(relation: K, callback?: (builder: any) => any): FlareBuilder<T, Args & { include: Record<K, true> }>;

  // Read Operations
  findMany(): Promise<BasePrisma.Result<ModelDelegate<T>, Args, 'findMany'>>;
  findFirst(): Promise<BasePrisma.Result<ModelDelegate<T>, Args, 'findFirst'>>;
  findFirstOrThrow(): Promise<NonNullable<BasePrisma.Result<ModelDelegate<T>, Args, 'findFirst'>>>;
  findUnique(): Promise<BasePrisma.Result<ModelDelegate<T>, Args, 'findUnique'>>;
  findUniqueOrThrow(): Promise<NonNullable<BasePrisma.Result<ModelDelegate<T>, Args, 'findUnique'>>>;
  all(): Promise<BasePrisma.Result<ModelDelegate<T>, Args, 'findMany'>>;
  get(): Promise<BasePrisma.Result<ModelDelegate<T>, Args, 'findMany'>>;
  pluck<K extends keyof RecordType<T>>(field: K): Promise<Array<RecordType<T>[K]>>;
  only<K extends keyof RecordType<T>>(field: K): Promise<RecordType<T>[K] | null>;

  // Write Operations
  create(data: CreateData<T>): Promise<RecordType<T>>;
  createMany(data: CreateManyData<T>[]): Promise<{ count: number }>;
  update(data: UpdateData<T>): Promise<RecordType<T>>;
  updateMany(data: UpdateData<T>): Promise<{ count: number }>;
  upsert(args?: { where?: WhereInput<T>; create: CreateData<T>; update: UpdateData<T> }): Promise<RecordType<T>>;
  delete(args?: { where?: WhereInput<T> }): Promise<RecordType<T>>;
  deleteMany(args?: { where?: WhereInput<T> }): Promise<{ count: number }>;

  // Aggregations
  count(): Promise<number>;
  sum<F extends SumFields<T>>(field: F): Promise<number | null>;
  avg<F extends AvgFields<T>>(field: F): Promise<number | null>;
  min<F extends MinFields<T>>(field: F): Promise<any>;
  max<F extends MaxFields<T>>(field: F): Promise<any>;
  aggregate(args: { _sum?: Partial<Record<SumFields<T>, true>>; _avg?: Partial<Record<AvgFields<T>, true>>; _min?: Partial<Record<MinFields<T>, true>>; _max?: Partial<Record<MaxFields<T>, true>>; _count?: boolean | Partial<Record<string, true>> }): Promise<any>;
  groupBy<B extends GroupByInput<T>>(by: B): FlareBuilder<T, Args & { by: B }>;
  having(condition: HavingInput<T>): FlareBuilder<T, Args & { having: HavingInput<T> }>;

  // Pagination
  paginate(page?: number, perPage?: number): Promise<PaginatedResult<BasePrisma.Result<ModelDelegate<T>, Args, 'findMany'>[number]>>;

  // Existence Check
  exists(existenceKey?: string): Promise<boolean>;

  // Utilities
  when(condition: boolean | (() => boolean), callback: (qb: FlareBuilder<T, Args>) => void): FlareBuilder<T, Args>;
  chunk(size: number, callback: (results: RecordType<T>[]) => Promise<void> | void): Promise<void>;
  clone(): FlareBuilder<T, Args>;
  getQuery(): Record<string, any>;
  toQuery(): Args;
}

// ============================================================================
// FlareClient - Properly typed for your Prisma schema
// ============================================================================

/**
 * FlareClient extends your PrismaClient with the fluent query builder API.
 */
export declare class FlareClient extends BasePrismaClient {
  constructor(options?: FlareClientOptions);

  /**
   * Creates a new FlareBuilder instance for the specified model.
   * @param modelName - The lowercase model name (e.g., 'user', 'post')
   */
  from<M extends ModelName>(modelName: M): FlareBuilder<M>;

  /**
   * Executes operations within a transaction.
   */
  transaction<R>(
    fn: (tx: FlareClient) => Promise<R>,
    options?: { maxWait?: number; timeout?: number; isolationLevel?: any }
  ): Promise<R>;
}
`;
}

/**
 * Generates the .prisma-flare directory with FlareClient configured for the project's
 * Prisma client output path.
 *
 * This function creates:
 * - node_modules/.prisma-flare/index.js (ESM)
 * - node_modules/.prisma-flare/index.cjs (CommonJS)
 * - node_modules/.prisma-flare/index.d.ts (TypeScript declarations)
 */
export function generateClient() {
  const rootDir = findProjectRoot(process.cwd());
  const config = loadConfig(rootDir);

  // Determine the Prisma client import path
  let prismaClientImport: string;

  if (config.prismaClientPath) {
    // User explicitly configured a path
    prismaClientImport = config.prismaClientPath;
  } else {
    // Auto-detect from schema.prisma
    prismaClientImport = getPrismaClientPath(rootDir);
  }

  // Resolve the import path for the generated file
  const nodeModulesDir = path.join(rootDir, 'node_modules');
  const prismaFlareDir = path.join(nodeModulesDir, '.prisma-flare');

  // Create the .prisma-flare directory
  if (!fs.existsSync(prismaFlareDir)) {
    fs.mkdirSync(prismaFlareDir, { recursive: true });
  }

  // Calculate the import path for the generated files
  let resolvedImport: string;
  let resolvedImportForJs: string;

  if (prismaClientImport === '@prisma/client') {
    resolvedImport = '@prisma/client';
    resolvedImportForJs = '@prisma/client';
  } else {
    // Convert absolute path to relative path from .prisma-flare directory
    resolvedImport = path.relative(prismaFlareDir, prismaClientImport);
    if (!resolvedImport.startsWith('.')) {
      resolvedImport = './' + resolvedImport;
    }
    resolvedImport = resolvedImport.replace(/\\/g, '/');
    // For ESM imports, directory imports are not allowed
    // The new "prisma-client" provider uses client.js, while "prisma-client-js" uses index.js
    const provider = getPrismaProvider(rootDir);
    const entryFile = provider === 'prisma-client' ? '/client.js' : '/index.js';
    resolvedImportForJs = resolvedImport + entryFile;
  }

  const isCustomOutput = hasCustomPrismaOutput(rootDir);
  const isNewProvider = getPrismaProvider(rootDir) === 'prisma-client';

  // Generate index.js or index.ts (ESM)
  // For new prisma-client provider, generate .ts since the Prisma client is TypeScript
  const esmContent = `// Generated by prisma-flare - DO NOT EDIT
// This file provides FlareClient configured for your Prisma client output path
// Import path: ${prismaClientImport}

import { PrismaClient, Prisma } from '${resolvedImportForJs}';
import { createFlareClient, FlareBuilder } from 'prisma-flare';

// Create and export FlareClient using the factory
export const FlareClient = createFlareClient(PrismaClient, Prisma);

// Re-export PrismaClient and Prisma for convenience
export { PrismaClient, Prisma };

// Re-export FlareBuilder for model class inheritance
export { FlareBuilder };
`;

  // Generate index.cjs (CommonJS)
  const cjsContent = `// Generated by prisma-flare - DO NOT EDIT
// This file provides FlareClient configured for your Prisma client output path
// Import path: ${prismaClientImport}

const { PrismaClient, Prisma } = require('${resolvedImport}');
const { createFlareClient, FlareBuilder } = require('prisma-flare');

// Create FlareClient using the factory
const FlareClient = createFlareClient(PrismaClient, Prisma);

module.exports = {
  FlareClient,
  PrismaClient,
  Prisma,
  FlareBuilder
};
`;

  // Generate index.d.ts (TypeScript declarations)
  // For custom output, we generate COMPLETE local type definitions using the custom Prisma namespace
  // For new prisma-client provider, import from client.js (TypeScript resolves .js to .ts)
  const dtsImport = isNewProvider ? resolvedImport + '/client.js' : resolvedImport;
  const dtsContent = isCustomOutput
    ? generateCustomOutputTypes(dtsImport)
    : `// Generated by prisma-flare - DO NOT EDIT
// This file provides FlareClient configured for your Prisma client output path

import { PrismaClient as BasePrismaClient, Prisma as BasePrisma } from '${resolvedImport}';
import type { FlareClientOptions } from 'prisma-flare';
import type { ModelName } from 'prisma-flare';
import type FlareBuilder from 'prisma-flare/flareBuilder';

// Re-export PrismaClient and Prisma from the configured path
export { BasePrismaClient as PrismaClient, BasePrisma as Prisma };

// FlareClient type that extends the project's PrismaClient
export declare class FlareClient extends BasePrismaClient {
  constructor(options?: FlareClientOptions);

  /**
   * Creates a new FlareBuilder instance for the specified model.
   * @param modelName - The lowercase model name (e.g., 'user', 'post')
   * @returns FlareBuilder instance
   */
  from<T extends ModelName>(modelName: T): FlareBuilder<T>;

  /**
   * Executes a transaction with the FlareClient capabilities.
   * @param fn - The transaction function.
   * @param options - Transaction options.
   * @returns The result of the transaction.
   */
  transaction<R>(
    fn: (tx: FlareClient) => Promise<R>,
    options?: { maxWait?: number; timeout?: number; isolationLevel?: any }
  ): Promise<R>;
}
`;

  // Write the files
  // For new prisma-client provider, generate .ts file that tsx/vitest can run
  const esmFile = isNewProvider ? 'index.ts' : 'index.js';
  fs.writeFileSync(path.join(prismaFlareDir, esmFile), esmContent);

  if (!isNewProvider) {
    fs.writeFileSync(path.join(prismaFlareDir, 'index.cjs'), cjsContent);
  }
  fs.writeFileSync(path.join(prismaFlareDir, 'index.d.ts'), dtsContent);

  // Create package.json for the generated module
  const packageJson = isNewProvider
    ? {
        name: '.prisma-flare',
        version: '0.0.0',
        main: './index.ts',
        module: './index.ts',
        types: './index.d.ts',
        type: 'module',
        exports: {
          '.': {
            types: './index.d.ts',
            import: './index.ts',
            default: './index.ts'
          }
        }
      }
    : {
        name: '.prisma-flare',
        version: '0.0.0',
        main: './index.cjs',
        module: './index.js',
        types: './index.d.ts',
        type: 'module',
        exports: {
          '.': {
            types: './index.d.ts',
            import: './index.js',
            require: './index.cjs'
          }
        }
      };

  fs.writeFileSync(
    path.join(prismaFlareDir, 'package.json'),
    JSON.stringify(packageJson, null, 2)
  );

  // Log success message
  if (isCustomOutput) {
    console.log(`✅ Generated prisma-flare client with custom Prisma output: ${prismaClientImport}`);
  } else {
    console.log(`✅ Generated prisma-flare client using @prisma/client`);
  }
  console.log(`   Location: ${prismaFlareDir}`);
  console.log(`\n   Import: import { FlareClient } from 'prisma-flare/client';`);
}
