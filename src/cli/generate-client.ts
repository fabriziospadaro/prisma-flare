import * as fs from 'fs';
import * as path from 'path';
import { findProjectRoot, loadConfig } from './config';
import { getPrismaClientPath, hasCustomPrismaOutput, getPrismaProvider } from './schema-parser';

/**
 * Generates FlareClient for the new prisma-client provider.
 * Creates a TypeScript file alongside the Prisma client that gets compiled
 * with the user's code. Includes complete type definitions for full type safety.
 */
function generateForNewProvider(rootDir: string, prismaClientPath: string): void {
  // Ensure the directory exists before writing
  if (!fs.existsSync(prismaClientPath)) {
    fs.mkdirSync(prismaClientPath, { recursive: true });
  }

  const flareFilePath = path.join(prismaClientPath, 'flare.ts');

  const content = `// Generated by prisma-flare - DO NOT EDIT
// FlareClient wrapper for the new prisma-client provider
// This file is TypeScript and will be compiled with your code

import { PrismaClient, Prisma } from './client.ts';
import { createFlareClient, FlareBuilder as FlareBuilderImpl } from 'prisma-flare';
import type { FlareClientOptions, PaginatedResult } from 'prisma-flare';

// ============================================================================
// Type Helpers - Using YOUR Prisma client types
// ============================================================================

/**
 * Extract model names from PrismaClient (lowercase delegate names only).
 */
type RawPrismaClientKeys = Exclude<
  Extract<keyof PrismaClient, string>,
  | '$connect'
  | '$disconnect'
  | '$on'
  | '$transaction'
  | '$use'
  | '$extends'
  | '$executeRaw'
  | '$executeRawUnsafe'
  | '$queryRaw'
  | '$queryRawUnsafe'
>;

export type ModelName = RawPrismaClientKeys;
export type ModelDelegate<T extends ModelName> = Uncapitalize<T> extends keyof PrismaClient
  ? PrismaClient[Uncapitalize<T>]
  : never;
export type RecordType<T extends ModelName> = NonNullable<Awaited<ReturnType<ModelDelegate<T>['findFirst']>>>;

/** Get Prisma args type for a model operation */
type PrismaArgs<T extends ModelName, A extends keyof ModelDelegate<T>> =
  ModelDelegate<T>[A] extends (args: infer Args) => any ? Args :
  ModelDelegate<T>[A] extends (args?: infer Args) => any ? Args : never;

/** FindMany args type */
type FindManyArgs<T extends ModelName> = NonNullable<PrismaArgs<T, 'findMany'>>;

/** Where input type (for findMany, etc.) */
type WhereInput<T extends ModelName> = FindManyArgs<T> extends { where?: infer W } ? W : never;

/** OrderBy input type */
type OrderByInput<T extends ModelName> = FindManyArgs<T> extends { orderBy?: infer O } ? O : never;

/** Select input type */
type SelectInput<T extends ModelName> = FindManyArgs<T> extends { select?: infer S } ? S : never;

/** Include input type */
type IncludeInput<T extends ModelName> = FindManyArgs<T> extends { include?: infer I } ? I : never;

/** Distinct input type */
type DistinctInput<T extends ModelName> = FindManyArgs<T> extends { distinct?: infer D } ? D : never;

/** Create data type */
type CreateData<T extends ModelName> = NonNullable<PrismaArgs<T, 'create'>> extends { data: infer D } ? D : never;

/** CreateMany data type */
type CreateManyData<T extends ModelName> = 'createMany' extends keyof ModelDelegate<T>
  ? NonNullable<PrismaArgs<T, 'createMany'>> extends { data: infer D } ? D : never
  : never;

/** Update data type */
type UpdateData<T extends ModelName> = NonNullable<PrismaArgs<T, 'update'>> extends { data: infer D } ? D : never;

/** Helper to make where clause optional */
type OptionalWhere<T> = T extends { where: any } ? Omit<T, 'where'> & { where?: T['where'] } : T;

/** Upsert args type (with optional where, includes compound unique constraints) */
type UpsertArgs<T extends ModelName> = OptionalWhere<NonNullable<PrismaArgs<T, 'upsert'>>>;

/** Delete args type (with optional where, includes compound unique constraints) */
type DeleteArgs<T extends ModelName> = OptionalWhere<NonNullable<PrismaArgs<T, 'delete'>>>;

/** DeleteMany args type */
type DeleteManyArgs<T extends ModelName> = NonNullable<PrismaArgs<T, 'deleteMany'>>;

/** GroupBy args type */
type GroupByArgs<T extends ModelName> = NonNullable<PrismaArgs<T, 'groupBy'>>;

/** GroupBy input type */
type GroupByInput<T extends ModelName> = GroupByArgs<T> extends { by: infer B } ? B : never;

/** Having input type */
type HavingInput<T extends ModelName> = GroupByArgs<T> extends { having?: infer H } ? H : never;

/** Aggregate args type */
type AggregateArgs<T extends ModelName> = NonNullable<PrismaArgs<T, 'aggregate'>>;

type SumFields<T extends ModelName> = AggregateArgs<T> extends { _sum?: infer S } ? keyof S : string;
type AvgFields<T extends ModelName> = AggregateArgs<T> extends { _avg?: infer A } ? keyof A : string;
type MinFields<T extends ModelName> = AggregateArgs<T> extends { _min?: infer M } ? keyof M : string;
type MaxFields<T extends ModelName> = AggregateArgs<T> extends { _max?: infer M } ? keyof M : string;

type IncludeMap<T extends ModelName> = NonNullable<IncludeInput<T>>;
type IncludeKey<T extends ModelName> = keyof IncludeMap<T> & string;

// ============================================================================
// FlareBuilder - Type definition using YOUR Prisma types
// ============================================================================

/**
 * FlareBuilder provides a fluent query builder API with full type safety.
 */
export interface IFlareBuilder<
  T extends ModelName,
  Args extends Record<string, any> = Record<string, never>
> {
  // Query Building Methods - Where conditions
  where(condition: WhereInput<T>): IFlareBuilder<T, Args & { where: WhereInput<T> }>;
  andWhere(condition: WhereInput<T>): IFlareBuilder<T, Args & { where: WhereInput<T> }>;
  orWhere(condition: WhereInput<T>): IFlareBuilder<T, Args & { where: WhereInput<T> }>;
  whereGroup(callback: (builder: IFlareBuilder<T, Record<string, never>>) => IFlareBuilder<T, any>, mode?: 'AND' | 'OR'): IFlareBuilder<T, Args & { where: WhereInput<T> }>;
  orWhereGroup(callback: (builder: IFlareBuilder<T, Record<string, never>>) => IFlareBuilder<T, any>): IFlareBuilder<T, Args & { where: WhereInput<T> }>;
  withId(id: number | string): IFlareBuilder<T, Args & { where: { id: number | string } }>;

  // Query Building Methods - Ordering and Limiting
  order(orderBy: OrderByInput<T>): IFlareBuilder<T, Args & { orderBy: OrderByInput<T> }>;
  first(key?: keyof RecordType<T> | string): IFlareBuilder<T, Args & { orderBy: any; take: number }>;
  last(key?: keyof RecordType<T> | string): IFlareBuilder<T, Args & { orderBy: any; take: number }>;
  limit(count: number): IFlareBuilder<T, Args & { take: number }>;
  skip(count: number): IFlareBuilder<T, Args & { skip: number }>;
  take(count: number): IFlareBuilder<T, Args & { take: number }>;
  offset(count: number): IFlareBuilder<T, Args & { skip: number }>;
  cursor(cursor: Record<string, any>): IFlareBuilder<T, Args>;
  distinct(fields: DistinctInput<T>): IFlareBuilder<T, Args & { distinct: DistinctInput<T> }>;

  // Query Building Methods - Selection
  select<S extends SelectInput<T>>(fields: S): IFlareBuilder<T, Args & { select: S }>;
  include<K extends IncludeKey<T>>(relation: K, callback?: (builder: any) => any): IFlareBuilder<T, Args & { include: Record<K, true> }>;

  // Read Operations
  findMany(): Promise<RecordType<T>[]>;
  findFirst(): Promise<RecordType<T> | null>;
  findFirstOrThrow(): Promise<RecordType<T>>;
  findUnique(): Promise<RecordType<T> | null>;
  findUniqueOrThrow(): Promise<RecordType<T>>;
  all(): Promise<RecordType<T>[]>;
  get(): Promise<RecordType<T>[]>;
  pluck<K extends keyof RecordType<T>>(field: K): Promise<Array<RecordType<T>[K]>>;
  only<K extends keyof RecordType<T>>(field: K): Promise<RecordType<T>[K] | null>;

  // Write Operations
  create(data: CreateData<T>): Promise<RecordType<T>>;
  createMany(data: CreateManyData<T>): Promise<{ count: number }>;
  update(data: UpdateData<T>): Promise<RecordType<T>>;
  updateMany(data: UpdateData<T>): Promise<{ count: number }>;
  upsert(args?: UpsertArgs<T>): Promise<RecordType<T>>;
  delete(args?: DeleteArgs<T>): Promise<RecordType<T>>;
  deleteMany(args?: DeleteManyArgs<T>): Promise<{ count: number }>;

  // Aggregations
  count(): Promise<number>;
  sum<F extends SumFields<T>>(field: F): Promise<number | null>;
  avg<F extends AvgFields<T>>(field: F): Promise<number | null>;
  min<F extends MinFields<T>>(field: F): Promise<any>;
  max<F extends MaxFields<T>>(field: F): Promise<any>;
  aggregate(args: { _sum?: Partial<Record<SumFields<T>, true>>; _avg?: Partial<Record<AvgFields<T>, true>>; _min?: Partial<Record<MinFields<T>, true>>; _max?: Partial<Record<MaxFields<T>, true>>; _count?: boolean | Partial<Record<string, true>> }): Promise<any>;
  groupBy<B extends GroupByInput<T>>(by: B): IFlareBuilder<T, Args & { by: B }>;
  having(condition: HavingInput<T>): IFlareBuilder<T, Args & { having: HavingInput<T> }>;

  // Pagination
  paginate(page?: number, perPage?: number): Promise<PaginatedResult<RecordType<T>>>;

  // Existence Check
  exists(existenceKey?: string): Promise<boolean>;

  // Utilities
  when(condition: boolean | (() => boolean), callback: (qb: IFlareBuilder<T, Args>) => void): IFlareBuilder<T, Args>;
  chunk(size: number, callback: (results: RecordType<T>[]) => Promise<void> | void): Promise<void>;
  clone(): IFlareBuilder<T, Args>;
  getQuery(): Record<string, any>;
  toQuery(): Args;
}

// Export the FlareBuilder implementation with our interface type
export const FlareBuilder = FlareBuilderImpl as unknown as {
  new <T extends ModelName>(model: ModelDelegate<T>): IFlareBuilder<T>;
};

// Type alias for external use
export type FlareBuilder<
  T extends ModelName,
  Args extends Record<string, any> = Record<string, never>
> = IFlareBuilder<T, Args>;

// ============================================================================
// FlareClient - Properly typed for your Prisma schema
// ============================================================================

const _FlareClient = createFlareClient(PrismaClient, Prisma);

/**
 * FlareClient interface with proper typing for your Prisma schema.
 */
export interface IFlareClient extends PrismaClient {
  from<M extends ModelName>(modelName: M): IFlareBuilder<M>;
  transaction<R>(
    fn: (tx: IFlareClient) => Promise<R>,
    options?: { maxWait?: number; timeout?: number; isolationLevel?: any }
  ): Promise<R>;
}

// Export the FlareClient implementation with our interface type
export const FlareClient = _FlareClient as unknown as {
  new (options?: FlareClientOptions): IFlareClient;
};

// Type alias for external use
export type FlareClient = IFlareClient;

// Re-export Prisma types for convenience
export { PrismaClient, Prisma };
`;

  fs.writeFileSync(flareFilePath, content);

  console.log(`✅ Generated prisma-flare client for new prisma-client provider`);
  console.log(`   Location: ${flareFilePath}`);
  console.log(`\n   Import: import { FlareClient } from '${path.relative(rootDir, flareFilePath).replace(/\\/g, '/').replace('.ts', '.js')}';`);
}

/**
 * Generates complete type definitions for custom Prisma output paths (prisma-client-js).
 * This includes a fully typed FlareBuilder that uses the local Prisma namespace.
 */
function generateCustomOutputTypes(resolvedImport: string): string {
  return `// Generated by prisma-flare - DO NOT EDIT
// Complete type definitions for custom Prisma client output path

import { PrismaClient as BasePrismaClient, Prisma as BasePrisma } from '${resolvedImport}';
import type { FlareClientOptions, PaginatedResult } from 'prisma-flare';

// Re-export PrismaClient and Prisma from the configured path
export { BasePrismaClient as PrismaClient, BasePrisma as Prisma };

// ============================================================================
// Type Helpers - Using YOUR Prisma client types
// ============================================================================

/**
 * Extract model names from PrismaClient (lowercase delegate names only).
 * Use lowercase model names like 'game', 'user', 'gameDetail' - NOT PascalCase.
 */
type RawPrismaClientKeys = Exclude<
  Extract<keyof BasePrismaClient, string>,
  | '$connect'
  | '$disconnect'
  | '$on'
  | '$transaction'
  | '$use'
  | '$extends'
  | '$executeRaw'
  | '$executeRawUnsafe'
  | '$queryRaw'
  | '$queryRawUnsafe'
>;

/** Model names from your Prisma schema (lowercase only, e.g., 'game', 'user') */
export type ModelName = RawPrismaClientKeys;

/** Get the delegate type for a model */
export type ModelDelegate<T extends ModelName> = Uncapitalize<T> extends keyof BasePrismaClient
  ? BasePrismaClient[Uncapitalize<T>]
  : never;

/** Get the record type for a model */
export type RecordType<T extends ModelName> = NonNullable<Awaited<ReturnType<ModelDelegate<T>['findFirst']>>>;

/** Get Prisma args type for a model operation */
type PrismaArgs<T extends ModelName, A extends keyof ModelDelegate<T>> =
  ModelDelegate<T>[A] extends (args: infer Args) => any ? Args :
  ModelDelegate<T>[A] extends (args?: infer Args) => any ? Args : never;

/** FindMany args type */
type FindManyArgs<T extends ModelName> = NonNullable<PrismaArgs<T, 'findMany'>>;

/** Where input type (for findMany, etc.) */
type WhereInput<T extends ModelName> = FindManyArgs<T> extends { where?: infer W } ? W : never;

/** OrderBy input type */
type OrderByInput<T extends ModelName> = FindManyArgs<T> extends { orderBy?: infer O } ? O : never;

/** Select input type */
type SelectInput<T extends ModelName> = FindManyArgs<T> extends { select?: infer S } ? S : never;

/** Include input type */
type IncludeInput<T extends ModelName> = FindManyArgs<T> extends { include?: infer I } ? I : never;

/** Distinct input type */
type DistinctInput<T extends ModelName> = FindManyArgs<T> extends { distinct?: infer D } ? D : never;

/** Create data type */
type CreateData<T extends ModelName> = NonNullable<PrismaArgs<T, 'create'>> extends { data: infer D } ? D : never;

/** CreateMany data type */
type CreateManyData<T extends ModelName> = 'createMany' extends keyof ModelDelegate<T>
  ? NonNullable<PrismaArgs<T, 'createMany'>> extends { data: infer D } ? D : never
  : never;

/** Update data type */
type UpdateData<T extends ModelName> = NonNullable<PrismaArgs<T, 'update'>> extends { data: infer D } ? D : never;

/** Helper to make where clause optional */
type OptionalWhere<T> = T extends { where: any } ? Omit<T, 'where'> & { where?: T['where'] } : T;

/** Upsert args type (with optional where, includes compound unique constraints) */
type UpsertArgs<T extends ModelName> = OptionalWhere<NonNullable<PrismaArgs<T, 'upsert'>>>;

/** Delete args type (with optional where, includes compound unique constraints) */
type DeleteArgs<T extends ModelName> = OptionalWhere<NonNullable<PrismaArgs<T, 'delete'>>>;

/** DeleteMany args type */
type DeleteManyArgs<T extends ModelName> = NonNullable<PrismaArgs<T, 'deleteMany'>>;

/** GroupBy args type */
type GroupByArgs<T extends ModelName> = NonNullable<PrismaArgs<T, 'groupBy'>>;

/** GroupBy input type */
type GroupByInput<T extends ModelName> = GroupByArgs<T> extends { by: infer B } ? B : never;

/** Having input type */
type HavingInput<T extends ModelName> = GroupByArgs<T> extends { having?: infer H } ? H : never;

/** Aggregate args type */
type AggregateArgs<T extends ModelName> = NonNullable<PrismaArgs<T, 'aggregate'>>;

type SumFields<T extends ModelName> = AggregateArgs<T> extends { _sum?: infer S } ? keyof S : string;
type AvgFields<T extends ModelName> = AggregateArgs<T> extends { _avg?: infer A } ? keyof A : string;
type MinFields<T extends ModelName> = AggregateArgs<T> extends { _min?: infer M } ? keyof M : string;
type MaxFields<T extends ModelName> = AggregateArgs<T> extends { _max?: infer M } ? keyof M : string;

type IncludeMap<T extends ModelName> = NonNullable<IncludeInput<T>>;
type IncludeKey<T extends ModelName> = keyof IncludeMap<T> & string;

// ============================================================================
// FlareBuilder - Complete type definition using YOUR Prisma types
// ============================================================================

/**
 * FlareBuilder provides a fluent query builder API with full type safety.
 * This version uses your project's Prisma types for complete autocomplete support.
 */
export declare class FlareBuilder<
  T extends ModelName,
  Args extends Record<string, any> = Record<string, never>
> {
  constructor(model: ModelDelegate<T>);

  // Query Building Methods - Where conditions
  where(condition: WhereInput<T>): FlareBuilder<T, Args & { where: WhereInput<T> }>;
  andWhere(condition: WhereInput<T>): FlareBuilder<T, Args & { where: WhereInput<T> }>;
  orWhere(condition: WhereInput<T>): FlareBuilder<T, Args & { where: WhereInput<T> }>;
  whereGroup(callback: (builder: FlareBuilder<T, Record<string, never>>) => FlareBuilder<T, any>, mode?: 'AND' | 'OR'): FlareBuilder<T, Args & { where: WhereInput<T> }>;
  orWhereGroup(callback: (builder: FlareBuilder<T, Record<string, never>>) => FlareBuilder<T, any>): FlareBuilder<T, Args & { where: WhereInput<T> }>;
  withId(id: number | string): FlareBuilder<T, Args & { where: { id: number | string } }>;

  // Query Building Methods - Ordering and Limiting
  order(orderBy: OrderByInput<T>): FlareBuilder<T, Args & { orderBy: OrderByInput<T> }>;
  first(key?: keyof RecordType<T> | string): FlareBuilder<T, Args & { orderBy: any; take: number }>;
  last(key?: keyof RecordType<T> | string): FlareBuilder<T, Args & { orderBy: any; take: number }>;
  limit(count: number): FlareBuilder<T, Args & { take: number }>;
  skip(count: number): FlareBuilder<T, Args & { skip: number }>;
  take(count: number): FlareBuilder<T, Args & { take: number }>;
  offset(count: number): FlareBuilder<T, Args & { skip: number }>;
  cursor(cursor: Record<string, any>): FlareBuilder<T, Args>;
  distinct(fields: DistinctInput<T>): FlareBuilder<T, Args & { distinct: DistinctInput<T> }>;

  // Query Building Methods - Selection
  select<S extends SelectInput<T>>(fields: S): FlareBuilder<T, Args & { select: S }>;
  include<K extends IncludeKey<T>>(relation: K, callback?: (builder: any) => any): FlareBuilder<T, Args & { include: Record<K, true> }>;

  // Read Operations
  findMany(): Promise<BasePrisma.Result<ModelDelegate<T>, Args, 'findMany'>>;
  findFirst(): Promise<BasePrisma.Result<ModelDelegate<T>, Args, 'findFirst'>>;
  findFirstOrThrow(): Promise<NonNullable<BasePrisma.Result<ModelDelegate<T>, Args, 'findFirst'>>>;
  findUnique(): Promise<BasePrisma.Result<ModelDelegate<T>, Args, 'findUnique'>>;
  findUniqueOrThrow(): Promise<NonNullable<BasePrisma.Result<ModelDelegate<T>, Args, 'findUnique'>>>;
  all(): Promise<BasePrisma.Result<ModelDelegate<T>, Args, 'findMany'>>;
  get(): Promise<BasePrisma.Result<ModelDelegate<T>, Args, 'findMany'>>;
  pluck<K extends keyof RecordType<T>>(field: K): Promise<Array<RecordType<T>[K]>>;
  only<K extends keyof RecordType<T>>(field: K): Promise<RecordType<T>[K] | null>;

  // Write Operations
  create(data: CreateData<T>): Promise<RecordType<T>>;
  createMany(data: CreateManyData<T>[]): Promise<{ count: number }>;
  update(data: UpdateData<T>): Promise<RecordType<T>>;
  updateMany(data: UpdateData<T>): Promise<{ count: number }>;
  upsert(args?: UpsertArgs<T>): Promise<RecordType<T>>;
  delete(args?: DeleteArgs<T>): Promise<RecordType<T>>;
  deleteMany(args?: DeleteManyArgs<T>): Promise<{ count: number }>;

  // Aggregations
  count(): Promise<number>;
  sum<F extends SumFields<T>>(field: F): Promise<number | null>;
  avg<F extends AvgFields<T>>(field: F): Promise<number | null>;
  min<F extends MinFields<T>>(field: F): Promise<any>;
  max<F extends MaxFields<T>>(field: F): Promise<any>;
  aggregate(args: { _sum?: Partial<Record<SumFields<T>, true>>; _avg?: Partial<Record<AvgFields<T>, true>>; _min?: Partial<Record<MinFields<T>, true>>; _max?: Partial<Record<MaxFields<T>, true>>; _count?: boolean | Partial<Record<string, true>> }): Promise<any>;
  groupBy<B extends GroupByInput<T>>(by: B): FlareBuilder<T, Args & { by: B }>;
  having(condition: HavingInput<T>): FlareBuilder<T, Args & { having: HavingInput<T> }>;

  // Pagination
  paginate(page?: number, perPage?: number): Promise<PaginatedResult<BasePrisma.Result<ModelDelegate<T>, Args, 'findMany'>[number]>>;

  // Existence Check
  exists(existenceKey?: string): Promise<boolean>;

  // Utilities
  when(condition: boolean | (() => boolean), callback: (qb: FlareBuilder<T, Args>) => void): FlareBuilder<T, Args>;
  chunk(size: number, callback: (results: RecordType<T>[]) => Promise<void> | void): Promise<void>;
  clone(): FlareBuilder<T, Args>;
  getQuery(): Record<string, any>;
  toQuery(): Args;
}

// ============================================================================
// FlareClient - Properly typed for your Prisma schema
// ============================================================================

/**
 * FlareClient extends your PrismaClient with the fluent query builder API.
 */
export declare class FlareClient extends BasePrismaClient {
  constructor(options?: FlareClientOptions);

  /**
   * Creates a new FlareBuilder instance for the specified model.
   * @param modelName - The lowercase model name (e.g., 'user', 'post')
   */
  from<M extends ModelName>(modelName: M): FlareBuilder<M>;

  /**
   * Executes operations within a transaction.
   */
  transaction<R>(
    fn: (tx: FlareClient) => Promise<R>,
    options?: { maxWait?: number; timeout?: number; isolationLevel?: any }
  ): Promise<R>;
}
`;
}

/**
 * Generates the .prisma-flare directory with FlareClient configured for the project's
 * Prisma client output path.
 *
 * This function creates:
 * - node_modules/.prisma-flare/index.js (ESM)
 * - node_modules/.prisma-flare/index.cjs (CommonJS)
 * - node_modules/.prisma-flare/index.d.ts (TypeScript declarations)
 */
export function generateClient() {
  const rootDir = findProjectRoot(process.cwd());
  const config = loadConfig(rootDir);

  // Determine the Prisma client import path
  let prismaClientImport: string;

  if (config.prismaClientPath) {
    // User explicitly configured a path
    prismaClientImport = config.prismaClientPath;
  } else {
    // Auto-detect from schema.prisma
    prismaClientImport = getPrismaClientPath(rootDir);
  }

  // Detect if using the new prisma-client provider (generates .ts files)
  const provider = getPrismaProvider(rootDir);
  const isNewProvider = provider === 'prisma-client';
  const isCustomOutput = hasCustomPrismaOutput(rootDir);

  // For the new prisma-client provider with custom output, generate TypeScript
  // alongside the Prisma client so it gets compiled with the user's code.
  if (isNewProvider && isCustomOutput) {
    generateForNewProvider(rootDir, prismaClientImport);
    // Continue to also generate .prisma-flare for model class imports
  }

  // Standard generation to node_modules/.prisma-flare/
  const nodeModulesDir = path.join(rootDir, 'node_modules');
  const prismaFlareDir = path.join(nodeModulesDir, '.prisma-flare');

  // Create the .prisma-flare directory
  if (!fs.existsSync(prismaFlareDir)) {
    fs.mkdirSync(prismaFlareDir, { recursive: true });
  }

  // Calculate the import path for the generated files
  let resolvedImport: string;
  let resolvedImportForJs: string;

  if (prismaClientImport === '@prisma/client') {
    resolvedImport = '@prisma/client';
    resolvedImportForJs = '@prisma/client';
  } else {
    // Convert absolute path to relative path from .prisma-flare directory
    resolvedImport = path.relative(prismaFlareDir, prismaClientImport);
    if (!resolvedImport.startsWith('.')) {
      resolvedImport = './' + resolvedImport;
    }
    resolvedImport = resolvedImport.replace(/\\/g, '/');

    // For ESM imports, directory imports are not allowed
    // prisma-client-js uses index.js, new prisma-client uses client.ts
    if (isNewProvider) {
      resolvedImportForJs = resolvedImport + '/client.ts';
    } else {
      resolvedImportForJs = resolvedImport + '/index.js';
    }
  }

  // Generate index.js (ESM) - Always output .js files since node_modules should contain compiled code
  // Bundlers like Turbopack/Next.js don't transpile .ts files in node_modules
  //
  // IMPORTANT: For custom output paths, we import FlareBuilder but export it via a const
  // assignment. This breaks the re-export chain so TypeScript uses our local .d.ts types
  // instead of following the import back to prisma-flare's bundled types.
  const esmContent = `// Generated by prisma-flare - DO NOT EDIT
// This file provides FlareClient configured for your Prisma client output path
// Import path: ${prismaClientImport}

import { PrismaClient, Prisma } from '${resolvedImportForJs}';
import { createFlareClient, FlareBuilder as _FlareBuilder } from 'prisma-flare';

// Create and export FlareClient using the factory
export const FlareClient = createFlareClient(PrismaClient, Prisma);

// Re-export PrismaClient and Prisma for convenience
export { PrismaClient, Prisma };

// Export FlareBuilder for model class inheritance
// Using const assignment so TypeScript uses the declarations from index.d.ts
export const FlareBuilder = _FlareBuilder;
`;

  // Generate index.d.ts (TypeScript declarations)
  // For custom output, we generate COMPLETE local type definitions
  // Use the same import path as the JS file for consistency
  const dtsContent = isCustomOutput
    ? generateCustomOutputTypes(resolvedImportForJs)
    : `// Generated by prisma-flare - DO NOT EDIT
// This file provides FlareClient configured for your Prisma client output path

import { PrismaClient as BasePrismaClient, Prisma as BasePrisma } from '${resolvedImport}';
import type { FlareClientOptions } from 'prisma-flare';
import type { ModelName } from 'prisma-flare';
import type FlareBuilder from 'prisma-flare/flareBuilder';

// Re-export PrismaClient and Prisma from the configured path
export { BasePrismaClient as PrismaClient, BasePrisma as Prisma };

// FlareClient type that extends the project's PrismaClient
export declare class FlareClient extends BasePrismaClient {
  constructor(options?: FlareClientOptions);

  /**
   * Creates a new FlareBuilder instance for the specified model.
   * @param modelName - The lowercase model name (e.g., 'user', 'post')
   * @returns FlareBuilder instance
   */
  from<T extends ModelName>(modelName: T): FlareBuilder<T>;

  /**
   * Executes a transaction with the FlareClient capabilities.
   * @param fn - The transaction function.
   * @param options - Transaction options.
   * @returns The result of the transaction.
   */
  transaction<R>(
    fn: (tx: FlareClient) => Promise<R>,
    options?: { maxWait?: number; timeout?: number; isolationLevel?: any }
  ): Promise<R>;
}
`;

  // Write the files - always output .js since node_modules should contain compiled code
  fs.writeFileSync(path.join(prismaFlareDir, 'index.js'), esmContent);
  fs.writeFileSync(path.join(prismaFlareDir, 'index.d.ts'), dtsContent);

  // Create package.json for the generated module (ESM only)
  const packageJson = {
    name: '.prisma-flare',
    version: '0.0.0',
    main: './index.js',
    types: './index.d.ts',
    type: 'module',
    exports: {
      '.': {
        types: './index.d.ts',
        import: './index.js'
      }
    }
  };

  fs.writeFileSync(
    path.join(prismaFlareDir, 'package.json'),
    JSON.stringify(packageJson, null, 2)
  );

  // Log success message
  if (isCustomOutput) {
    console.log(`✅ Generated prisma-flare client with custom Prisma output: ${prismaClientImport}`);
  } else {
    console.log(`✅ Generated prisma-flare client using @prisma/client`);
  }
  console.log(`   Location: ${prismaFlareDir}`);
  console.log(`\n   Import: import { FlareClient } from 'prisma-flare/client';`);
}
